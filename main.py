import re
import nmap
import argparse
import requests
import json
import os
import subprocess

nmap = nmap.PortScanner()
class InvalidIPAddressError(Exception):
    pass

class NiktoPathError(Exception):
    def __init__(self, message):
        self.message = message

    def __str__(self):
        return f'Error path for Nikto: {self.message}'


class FfufPathError(Exception):
    def __init__(self, message):
        self.message = message

    def __str__(self):
        return f'Error path for Ffuf: {self.message}'

class WordlistPathError(Exception):
    def __init__(self, message):
        self.message = message

    def __str__(self):
        return f'Error path for Ffuf wordlist: {self.message}'
def validate_ip_address(ip):
    ip_pattern = re.compile(
        r'^(25[0-5]|2[0-4][0-9]|[0-1]?[0-9][0-9]?)\.'
        r'(25[0-5]|2[0-4][0-9]|[0-1]?[0-9][0-9]?)\.'
        r'(25[0-5]|2[0-4][0-9]|[0-1]?[0-9][0-9]?)\.'
        r'(25[0-5]|2[0-4][0-9]|[0-1]?[0-9][0-9]?)$'
    )
    if not ip_pattern.match(ip):
        raise InvalidIPAddressError("Błąd! Podany adres IP jest nieprawidłowy.")
    else:
        return ip
class ConfigManager:
    def __init__(self, nikto_path=None, ffuf_path=None, ffuf_wordlist_path=None):
        self.nikto_path = nikto_path
        self.ffuf_path = ffuf_path
        self.ffuf_wordlist_path = ffuf_wordlist_path

    def set_nikto_path(self, nikto_path):
        self.nikto_path = nikto_path

    def set_ffuf_path(self, ffuf_path):
        self.ffuf_path = ffuf_path

    def get_nikto_path(self):
        return self.nikto_path

    def get_ffuf_path(self):
        return self.ffuf_path

    def get_ffuf_wordlist_path(self):
        return self.ffuf_wordlist_path

    def get_config(self):
        return {
            'nikto_path': self.nikto_path,
            'ffuf_path': self.ffuf_path,
            'ffuf_wordlist_path': self.ffuf_wordlist_path
        }
    def save_config(self, file_path):
        config_data = self.get_config()
        with open(file_path, 'w') as config_file:
            json.dump(config_data, config_file)

    def load_config(self, file_path):
        with open(file_path, 'r') as config_file:
            config_data = json.load(config_file)
            self.nikto_path = config_data.get('nikto_path')
            self.ffuf_path = config_data.get('ffuf_path')
            self.ffuf_wordlist_path = config_data.get('ffuf_wordlist_path')

class Scanner:
    def __init__(self, ip_address, config_manager=None, ports=None):
        self.ip_address = ip_address
        self.config_manager = config_manager
        self.ports = ports

    #Function that's scan ip for all or provided ports, then it returns results in a list
    def scan_ports(self):
        print(self.ports)
        scan_argument = f'-p {self.ports}' if self.ports else '-Pn -p-'
        ports_result = nmap.scan(self.ip_address, arguments=scan_argument)
        return ports_result

class Formatter:
    def __init__(self, ports_result, ip_address):
        self.ports_result = ports_result
        self.ip_address = ip_address
        self.open_ports = None

    # list from the previous function is provided to get_open_ports, this function are searching for open ports from results
    def get_open_ports(self):
        self.open_ports = []
        for host, info in self.ports_result['scan'].items():
            print("-" * 50)
            print(f'Host: {host}({info["hostnames"][0]["name"]})')
            print(f'State: {info["status"]["state"]}')
            print("-" * 50)
            for port, port_info in self.ports_result['scan'][self.ip_address]['tcp'].items():
                if port_info.get('state') == 'open':
                    print("Port {}, state: {}".format(port, port_info["state"]))
                    if port not in self.open_ports:
                        self.open_ports.append(port)
                    print("-" * 50)
            print("\n\n")
        return self.open_ports
    # after all get_detailed_information gets list of open ports and searching for a detailed informations of it
    def get_detailed_information(self):
        ports_to_scan = ','.join(map(str, self.open_ports))

        os_information = nmap.scan(self.ip_address, arguments=f"-O -A -sV -p {ports_to_scan}")
        ports_data = {}

        for ip, info in os_information['scan'].items():
            print("DETAILED INFORMATIONS ABOUT PORT AND SYSTEM")
            print("-" * 50)
            for port, port_info in info['tcp'].items():
                print(f'Port {port} | {port_info["state"]}:')
                print(f"  Service: {port_info['name']}")
                print(f"  Product: {port_info['product']}")
                print(f"  cpe: {port_info['cpe']}")
                print(f"  Version: {port_info['version']}") if port_info['version'] else None,
                print(f"  Extra Info: {port_info['extrainfo']}") if port_info['extrainfo'] else None
                print("-" * 50)
                port_data = {
                    'service': port_info['name'],
                    'product': port_info['product'],
                    'cpe': port_info['cpe'],
                    'version': port_info['version'] if port_info['version'] else None,
                    'extrainfo': port_info['extrainfo'] if port_info['extrainfo'] else None
                }
                ports_data[port] = port_data

            for osmatch in info.get('osmatch', []):
                print(f"OS Match Name: {osmatch['name']}")
                os_info = {
                    'os_match_name': osmatch['name'],
                    'os_classes': []
                }
                for osclass in osmatch.get('osclass', []):
                    print(f"  Vendor: {osclass['vendor']}")
                    print(f"  OS Family: {osclass['osfamily']}")
                    print(f"  OS Gen: {osclass['osgen']}")
                    print(f"  Accuracy: {osclass['accuracy']}")
                    print(f"  CPE: {', '.join(osclass.get('cpe', []))}")
                    print("-" * 50)
                    os_class_data = {
                        'vendor': osclass['vendor'],
                        'os_family': osclass['osfamily'],
                        'os_gen': osclass['osgen'],
                        'accuracy': osclass['accuracy'],
                        'cpe': osclass.get('cpe', [])
                    }
                    os_info['os_classes'].append(os_class_data)
                    print("-" * 50)
            ports_data[port]['os_info'] = os_info
        return ports_data

class FullScan(Scanner):
    def __init__(self, ip_address, config_manager, ports=None):
        super().__init__(ip_address, config_manager, ports)
    def run_nikto_ffuff_scan(self, address, ports_data):
        http_port = None
        https_port = None

        for port, data in ports_data.items():
            if data['service'] == 'http':
                http_port = port
            elif data['service'] == 'https':
                https_port = port

        if https_port:
            self.run_nikto(address, https_port)
            self.run_ffuf(address, https_port)
        elif http_port:
            self.run_nikto(address, http_port)
            self.run_ffuf(address, http_port)
        else:
            print("HTTP and HTTPS ports not found")

    def run_nikto(self, address, port):
        if os.name == 'nt':
            nikto_path = self.config_manager.get_nikto_path()
        else:
            nikto_path = "nikto"
        if not nikto_path:
            raise NiktoPathError("Path to Nikto isn't configured")

        command = ["perl", nikto_path, "-h", f"{address}:{port}"]
        subprocess.run(command)

    def run_ffuf(self, address, port):
        if os.name == 'nt':
            ffuf_path = self.config_manager.get_ffuf_path()
        else:
            ffuf_path = 'ffuf'

        wordlist_path = self.config_manager.get_ffuf_wordlist_path()

        if not ffuf_path:
            raise ConfigError("Path to Ffuf isn't configured")
        if not wordlist_path:
            raise ConfigError("Path to Ffuf wordlist isn't configured")
        command = [ffuf_path, "-u", f"{address}:{port}", "-w", wordlist_path]
        subprocess.run(command)
class ScanPorts(Scanner):
    def __init__(self):
        self.ip_address = ip_address
        self.ports = ports


class NVDConnector:
    BASE_URL = "https://services.nvd.nist.gov/rest/json/cves/2.0"

    def cpe_2_2_to_2_3(self, cpe_2_2):

        if not cpe_2_2.startswith("cpe:/"):
            raise ValueError("Invalid CPE format")

        cpe_2_2 = cpe_2_2[len("cpe:/"):]

        parts = cpe_2_2.split(":")

        cpe_2_3 = "cpe:2.3:" + ":".join(parts)

        return cpe_2_3

    def search_cve(self, cpe_name):

        cpe_name = self.cpe_2_2_to_2_3(cpe_name)
        params = {'cpeName': cpe_name}

        response = requests.get(self.BASE_URL, params=params)
        if response.status_code == 200:
            cve_data = response.json()
            for vulns in cve_data['vulnerabilities']:
                print("CVE ID:", vulns['cve']['id'])
                print("Description:", vulns['cve']['descriptions'][0]['value'])
                print("Score: ", vulns['cve']['metrics']['cvssMetricV2'][0]['cvssData']['baseScore'])
                print("Severity: ", vulns['cve']['metrics']['cvssMetricV2'][0]['baseSeverity'])
        else:
            response.raise_for_status()

    def show_cve(self, ports_data):
        for port, data in ports_data.items():
            print(f"{port}")
            if 'cpe' in data and data['cpe']:
                cpe = data['cpe']
                cve_data = self.search_cve(cpe)
                if cve_data:
                    print("CVEs: ")
                    print(cve_data)
                else:
                    print('Nothing found')
            else:
                print('There is nothing CVE associated with provided CPE')


def menu():
    parser = argparse.ArgumentParser(description="Automate pentest tool")
    parser.add_argument('-i', '--ip', help="Ip address in format 0.0.0.0", type=validate_ip_address)
    parser.add_argument('-p', '--ports', nargs='+', help="Ports to scan")
    parser.add_argument('-a', '--fullscan', action='store_true', help="Execute full scan on network")
    parser.add_argument("--nikto-path", help="Path to Nikto")
    parser.add_argument("--ffuf-path", help="Path to Ffuf")

    try:
        args = parser.parse_args()
    except InvalidIPAddressError as e:
        print(e)
        return

    config_manager = ConfigManager()
    config_manager.load_config('config.json')

    if args.nikto_path:
        nikto_path = args.nikto_path
        config_manager.set_nikto_path(nikto_path)
        config_manager.save_config('config.json')

    if args.ffuf_path:
        ffuf_path = args.ffuf_path
        config_manager.set_ffuf_path(ffuf_path)
        config_manager.save_config('config.json')

    if args.fullscan == True:
        print("[*] Config loaded")
        if not args.ports:
            print("No ports provided, scanning all ports!")
            fullscan = FullScan(args.ip, config_manager)
        else:
            args.ports = ','.join(map(str, args.ports))
            fullscan = FullScan(args.ip, config_manager, args.ports)

        ports_results = fullscan.scan_ports()
        formatter = Formatter(ports_results, args.ip)
        formatter.get_open_ports()
        ports_data = formatter.get_detailed_information()

        # this is for testing function!!!
#        ports_data = {
#            63342: {
#               'state': 'open',
#                'service': 'http',
#                'product': 'PyCharm',
#                'cpe': 'cpe:2.3:o:microsoft:windows_10:1607:*:*:*:*:*:*:*',
#                'version': '2023.3.3'
#            }
#        }

        fullscan.run_nikto_ffuff_scan(args.ip, ports_data)
        nvd_connector = NVDConnector()
        nvd_connector.show_cve(ports_data)

def main():
    menu()

if __name__ == "__main__":
    main()
