import re
import nmap
import argparse
import requests
import json
import os
import subprocess
from tabulate import tabulate

nmap = nmap.PortScanner()
class InvalidIPAddressError(Exception):
    pass

class NiktoPathError(Exception):
    def __init__(self, message):
        self.message = message

    def __str__(self):
        return f'Error path for Nikto: {self.message}'


class FfufPathError(Exception):
    def __init__(self, message):
        self.message = message

    def __str__(self):
        return f'Error path for Ffuf: {self.message}'

class WordlistPathError(Exception):
    def __init__(self, message):
        self.message = message

    def __str__(self):
        return f'Error path for Ffuf wordlist: {self.message}'
def validate_ip_address(ip):
    ip_pattern = re.compile(
        r'^(25[0-5]|2[0-4][0-9]|[0-1]?[0-9][0-9]?)\.'
        r'(25[0-5]|2[0-4][0-9]|[0-1]?[0-9][0-9]?)\.'
        r'(25[0-5]|2[0-4][0-9]|[0-1]?[0-9][0-9]?)\.'
        r'(25[0-5]|2[0-4][0-9]|[0-1]?[0-9][0-9]?)$'
    )
    if not ip_pattern.match(ip):
        raise InvalidIPAddressError("Error! The provided IP address is invalid.")
    else:
        return ip
class ConfigManager:
    def __init__(self, nikto_path=None, ffuf_path=None, ffuf_wordlist_path=None, api_key=None):
        self.nikto_path = nikto_path
        self.ffuf_path = ffuf_path
        self.ffuf_wordlist_path = ffuf_wordlist_path
        self.api_key = api_key

    def set_nikto_path(self, nikto_path):
        self.nikto_path = nikto_path

    def set_ffuf_path(self, ffuf_path):
        self.ffuf_path = ffuf_path

    def get_nikto_path(self):
        return self.nikto_path

    def get_ffuf_path(self):
        return self.ffuf_path

    def get_ffuf_wordlist_path(self):
        return self.ffuf_wordlist_path

    def get_api_key(self):
        return self.api_key

    def get_config(self):
        return {
            'nikto_path': self.nikto_path,
            'ffuf_path': self.ffuf_path,
            'ffuf_wordlist_path': self.ffuf_wordlist_path,
            'api_key': self.api_key
        }
    def save_config(self, file_path):
        config_data = self.get_config()
        with open(file_path, 'w') as config_file:
            json.dump(config_data, config_file)

    def load_config(self, file_path):
        with open(file_path, 'r') as config_file:
            config_data = json.load(config_file)
            self.nikto_path = config_data.get('nikto_path')
            self.ffuf_path = config_data.get('ffuf_path')
            self.ffuf_wordlist_path = config_data.get('ffuf_wordlist_path')
            self.api_key = config_data.get('api_key')

class Scanner:
    def __init__(self, ip_address, config_manager=None, ports=None):
        self.ip_address = ip_address
        self.config_manager = config_manager
        self.ports = ports

    #Function that's scan ip for all or provided ports, then it returns results in a list
    def scan_ports(self):
        if self.ports:
            ports_str = ','.join(map(str, self.ports))
        scan_argument = f'-p {ports_str}' if self.ports else '-Pn -p-'
        ports_result = nmap.scan(self.ip_address, arguments=scan_argument)
        return ports_result

class Formatter:
    def __init__(self, ports_result, ip_address):
        self.ports_result = ports_result
        self.ip_address = ip_address
        self.open_ports = None

    # list from the previous function is provided to get_open_ports, this function are searching for open ports from results
    def get_open_ports(self):
        self.open_ports = []
        ports_tab = []
        for host, info in self.ports_result['scan'].items():
            print(f'Host: {host}({info["hostnames"][0]["name"]})')
            print(f'State: {info["status"]["state"]}')
            for port, port_info in self.ports_result['scan'][self.ip_address]['tcp'].items():
                if port_info.get('state') == 'open':
                    ports_tab.append([port, port_info['state']])
                    if port not in self.open_ports:
                        self.open_ports.append(port)
        print(tabulate(ports_tab, headers=['Port', 'State'], tablefmt='grid'))
        return self.open_ports
    # after all get_detailed_information gets list of open ports and searching for a detailed informations of it
    def get_detailed_information(self):
        ports_to_scan = ','.join(map(str, self.open_ports))
        os_information = nmap.scan(self.ip_address, arguments=f"-O -A -sV -p {ports_to_scan}")
        ports_data = {}
        ports_tab = []

        for ip, info in os_information['scan'].items():
            print("DETAILED INFORMATIONS ABOUT PORT AND SYSTEM")
            for port, port_info in info['tcp'].items():
                port_data = {
                    'service': port_info['name'],
                    'product': port_info['product'],
                    'cpe': port_info['cpe'],
                    'version': port_info['version'] if port_info['version'] else None,
                    'extrainfo': port_info['extrainfo'] if port_info['extrainfo'] else None
                }
                ports_data[port] = port_data

            for port, info in ports_data.items():
                row = [port, info['service'], info['product'], info['cpe'], info['version'], info['extrainfo']]
                ports_tab.append(row)

            print(tabulate(ports_tab, headers=['Port', 'Service', 'Product', 'CPE', 'Version', 'Extra Info'], tablefmt='grid'))

            os_info = {'os_classes': []}
            for osmatch in info.get('osmatch', []):
                print(f"OS Match Name: {osmatch['name']}")
                os_info = {
                    'os_match_name': osmatch['name'],
                    'os_classes': []
                }
                for osclass in osmatch.get('osclass', []):
                    print(f"  Vendor: {osclass['vendor']}")
                    print(f"  OS Family: {osclass['osfamily']}")
                    print(f"  OS Gen: {osclass['osgen']}")
                    print(f"  Accuracy: {osclass['accuracy']}")
                    print(f"  CPE: {', '.join(osclass.get('cpe', []))}")
                    os_class_data = {
                        'vendor': osclass['vendor'],
                        'os_family': osclass['osfamily'],
                        'os_gen': osclass['osgen'],
                        'accuracy': osclass['accuracy'],
                        'cpe': osclass.get('cpe', [])
                    }
                    os_info['os_classes'].append(os_class_data)
            ports_data[port]['os_info'] = os_info
        return ports_data

class FullScan(Scanner):
    def __init__(self, ip_address, config_manager, ports=None):
        super().__init__(ip_address, config_manager, ports)
    def run_nikto_ffuff_scan(self, address, ports_data):
        http_port = None
        https_port = None

        for port, data in ports_data.items():
            if data['service'] == 'http':
                http_port = port
                prefix = 'http'
                break
            elif data['service'] == 'https':
                https_port = port
                prefix = 'https'
                break

        if https_port:
            self.run_nikto(address, https_port)
            self.run_ffuf(address, https_port, prefix)
        elif http_port:
            self.run_nikto(address, http_port)
            self.run_ffuf(address, http_port, prefix)
        else:
            print("HTTP and HTTPS ports not found")

    def run_nikto(self, address, port):
        if os.name == 'nt':
            nikto_path = self.config_manager.get_nikto_path()
            command = ["perl", nikto_path, "-h", f"{address} -p {port}"]
            if not nikto_path:
                raise NiktoPathError("Path to Nikto isn't configured")
        else:
            command = ["nikto", "-h", f"{address}:{port}"]
        subprocess.run(command)

    def run_ffuf(self, address, port, prefix):
        wordlist_path = self.config_manager.get_ffuf_wordlist_path()
        if not wordlist_path:
            raise ConfigError("Path to Ffuf wordlist isn't configured")

        if os.name == 'nt':
            ffuf_path = self.config_manager.get_ffuf_path()
            if not ffuf_path:
                raise ConfigError("Path to Ffuf isn't configured")
            command = [ffuf_path, "-u", f"{prefix}://{address}:{port}/FFUF", "-w", wordlist_path]
        else:
            command = ["ffuf", "-u", f"{prefix}://{address}:{port}", "-w", wordlist_path]
        subprocess.run(command)
class PortScanner(Scanner):
    def __init__(self, ip_address):
        super().__init__(ip_address)

class HostScanner(Scanner):
    def __init__(self, ip_address):
        super().__init__(ip_address)

    def scan_subnet(self):
        return nmap.scan(self.ip_address)

class OSScanner(Scanner):
    def __init__(self, ip_address):
        super().__init__(ip_address)

    def scan_os(self):
        os_result = nmap.scan(self.ip_address, arguments='-O')
        return os_result


class NVDConnector:
    def __init__(self, api_key=None):
        self.BASE_URL = "https://services.nvd.nist.gov/rest/json/cves/2.0"
        self.api_key = api_key

    def cpe_2_2_to_2_3(self, cpe_2_2):

        if cpe_2_2.startswith("cpe:2.3:"):
            return cpe_2_2

        if not cpe_2_2.startswith("cpe:/"):
            raise ValueError("Invalid CPE format")

        cpe_2_2 = cpe_2_2[len("cpe:/"):]

        parts = cpe_2_2.split(":")

        cpe_2_3 = "cpe:2.3:" + ":".join(parts) + ":*:*:*:*:*:*:*"

        return cpe_2_3

    def search_cve(self, cpe_name):

        cpe_name = self.cpe_2_2_to_2_3(cpe_name)
        params = {'cpeName': cpe_name}

        if self.api_key:
            params['api_key'] = self.api_key

        response = requests.get(self.BASE_URL, params=params)
        if response.status_code == 200:
            cve_data = []
            cve_response = response.json()
            for vulns in cve_response['vulnerabilities']:
                if 'cvssMetricV2' in vulns['cve']['metrics']:
                    base_score = vulns['cve']['metrics']['cvssMetricV2'][0]['cvssData']['baseScore']
                    severity = vulns['cve']['metrics']['cvssMetricV2'][0]['baseSeverity']
                else:
                    base_score = vulns['cve']['metrics']['cvssMetricV31'][0]['cvssData']['baseScore']
                    severity = vulns['cve']['metrics']['cvssMetricV31'][0]['cvssData']['baseSeverity']
                cve_info = {
                    "CVE ID": vulns['cve']['id'],
                    "Score": base_score,
                    "Severity": severity
                }
                cve_data.append(cve_info)
            return cve_data
        elif response.status_code == 404:
            print("CPE {} not found".format(cpe_name))
        else:
            response.raise_for_status()

    def show_cve(self, ports_data):
        table_headers = ['CVE ID', 'Score', 'Severity']
        severity_meaning = {
            'LOW': 'Low severity level: Attacker would require special conditions or system configuration to exploit the vulnerability.',
            'MEDIUM': 'Medium severity level: Attacker may exploit the vulnerability, but it requires certain conditions or user interaction.',
            'HIGH': 'High severity level: Attacker can exploit the vulnerability without requiring special conditions or user interaction.',
            'CRITICAL': 'Critical severity level: Vulnerability has severe consequences without needing user interaction, such as remote code execution or system takeover.'
        }
        print("Recommendations for choosing CVE for attack:")
        print("Choose CVE with high or critical severity level, as these vulnerabilities are most critical and can be used for remote code execution or system takeover.")
        print("Description of severity levels:")
        for severity, meaning in severity_meaning.items():
            print(f"{severity}: {meaning}")

        for port, data in ports_data.items():
            print(f"At port: {port}")
            if 'cpe' in data and data['cpe']:
                cpe = data['cpe']
                cve_data = self.search_cve(cpe)
                if cve_data:
                    cve_data = self.sort_cve_by_score(cve_data)
                    print("List of CVE:")
                    table_data = [[cve['CVE ID'], cve['Score'], cve['Severity']] for cve in cve_data]
                    print(tabulate(table_data, headers=table_headers, tablefmt='grid'))
            else:
                print('There is nothing CVE associated with provided CPE')

    def sort_cve_by_score(self, cve_data):
        sorted_cve = sorted(cve_data, key=lambda x: x['Score'], reverse=True)
        return sorted_cve


def menu():
    parser = argparse.ArgumentParser(description="Automate pentest tool")
    parser.add_argument('-H', '--host', help="Ip address in format 0.0.0.0")
    parser.add_argument('-p', '--ports', nargs='+', help="Ports to scan")
    parser.add_argument('-f', '--fullscan', action='store_true', help="Execute full scan on network")
    parser.add_argument("--portscan", help="Scan ports", action="store_true")
    parser.add_argument("--subnet", help="Scan a subnet instead of a single host", action="store_true")
    parser.add_argument("--osscan", help="Scan operating system", action="store_true")
    parser.add_argument("--nikto-path", help="Path to Nikto")
    parser.add_argument("--ffuf-path", help="Path to Ffuf")
    args = parser.parse_args()


    config_manager = ConfigManager()
    config_manager.load_config('config.json')

    if args.nikto_path:
        nikto_path = args.nikto_path
        config_manager.set_nikto_path(nikto_path)
        config_manager.save_config('config.json')

    if args.ffuf_path:
        ffuf_path = args.ffuf_path
        config_manager.set_ffuf_path(ffuf_path)
        config_manager.save_config('config.json')

    if args.fullscan == True:

        try:
            args.host
        except InvalidIPAddressError as e:
            print(e)

        if not args.ports:
            print("No ports provided, scanning all ports!")
            fullscan = FullScan(args.host, config_manager)
        else:
            args.ports
            fullscan = FullScan(args.host, config_manager, args.ports)

        ports_results = fullscan.scan_ports()
        formatter = Formatter(ports_results, args.host)
        formatter.get_open_ports()
        ports_data = formatter.get_detailed_information()
        fullscan.run_nikto_ffuff_scan(args.host, ports_data)
        nvd_connector = NVDConnector(config_manager.api_key)
        nvd_connector.show_cve(ports_data)

    elif args.portscan:
        if not args.ports:
            print("No ports provided, scanning all ports!")
            port_scanner = PortScanner(args.host)
        else:
            args.ports = args.ports.split(",")
            port_scanner = PortScanner(args.host, config_manager, args.ports)

        ports_results = port_scanner.scan_ports()
        formatter = Formatter(ports_results, args.host)
        formatter.get_open_ports()
        result = formatter.get_detailed_information()

    elif args.subnet:
        host_scanner = HostScanner(args.host)
        result = host_scanner.scan_subnet()
        print(result)
    elif args.osscan:
        os_scanner = OSScanner(args.host)
        result = os_scanner.scan_os()
        print(result)
    else:
        host_scanner = HostScanner(args.host)
        result = host_scanner.scan_host()
        print(result)
def main():
    menu()

if __name__ == "__main__":
    main()
